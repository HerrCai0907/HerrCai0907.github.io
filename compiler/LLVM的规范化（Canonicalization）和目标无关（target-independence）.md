本文翻译自：[LLVM: Canonicalization and target-independence](https://link.zhihu.com/?target=https%3A//www.npopov.com/2023/04/10/LLVM-Canonicalization-and-target-independence.html)
理论上讲，优化编译器的后端应该是执行 CPU 架构特定优化的部分，而中端是目标无关的， 但实际上，中端确实需要考虑目标的某些属性。 但是，我们需要仔细管理这些以维护编译器的整体架构。在本文中，我想讨论目标的相关信息可以通过哪些方式影响 LLVM 中端，更重要的是，不允许以哪些方式影响它。
### 内存布局
每个 IR 模块都有一个关联的内存布局，它指定有关基本类型的大小和对齐方式的信息，以及其他基本信息。 这决定了目标是小端还是大端，指针是 32 位还是 64 位，双精度数是 4 字节还是 8 字节对齐，等等。
LLVM 过去允许没有内存布局的模块，这在理论上是完全独立于目标的。 但事实证明与目标相关的方面无论如何都会进入 IR，例如为了解决同一个对象在ABI中的不同处理方式。现在对于LLVM中端，所有结构的内存布局都是已知的，可以在中端的任何地方使用的目标相关的内存布局信息。
### 目标库信息（TLI）
TargetLibraryAnalysis 提供的 TargetLibraryInfo (TLI) 确定假定哪些库调用在目标上可用。
这部分不是关于目标 CPU 体系结构，而是更多关于目标操作系统和环境。例如，如果您的目标是 x86_64-unknown-linux-gnu（并且不使用 -ffreestanding 或类似的），LLVM 将假定某些符号由 glibc 提供。当以 linux-gnu 为目标时，对已知长度字符串的 strrchr() 调用将被转换为 memrchr()，而在以 windows-msvc 为目标时则不会发生同样的情况。 这是因为 strrchr() 是一个标准的 C 函数，而 memrchr() 是一个 GNU 扩展。中端一般可以用TLI。 但是这个信息需要在pass manager中显式的声明。许多pass实际上不需要这个，但增加额外的 TLI 依赖也没什么问题。
### 目标转换信息（TTI）
TargetIRAnalysis 提供的 TargetTransformInfo (TTI) 提供了多种可以被后端覆盖的挂钩。 这包括通用成本建模 API（该指令的反向吞吐量是多少？）和用于特定pass的专用 API（该目标的展开首选项是什么？）。
中端 TTI 的使用受到严格控制。 我们区分了不允许使用 TTI 的独立于目标的规范化pass和可以使用 TTI 的成本模型驱动pass。成本模型驱动pass的示例是 LoopVectorize、SLPVectorize 或 VectorCombine。 这很明显，因为向量化基本上都是基于成本模型的。 只有当我们能够证明向量指令比标量指令更便宜时，向量化才有利可图。
### 规范化pass
像 InstCombine 这样的规范化pass旨在以其他pass可以依赖的“规范形式”生成 IR。 选择这种规范形式是基于它对进一步分析和转换的服从程度，而不是它对特定目标的好处。 规范形式对于某些甚至所有目标来说可能是不受欢迎的，因为方便分析的并不总是适合 CPU 的。
在规范形式不适合目标的情况下，需要实施后端撤消转换。 撤消转换通常存在于 CodeGenPrepare (CGP)、DAGCombine 或某些特定于目标的代码中。 CGP 用于需要跨基本块工作的撤消转换，因为这在 DAGCombine 中是不可能的。
为什么我们要费力地让 InstCombine 将 IR 转换为一种形式，然后让后端撤消它。 如果我们首先允许后端选择退出转换，会不会更简单？考虑两个等效代码模式 A 和 B。如果我们有从 A 到 B 的 InstCombine 转换，但目标更喜欢 A，我们可以抑制转换。 但是，首先这个 InstCombine 转换对 B 的情况没有任何作用。 因此，我们需要从 B 到 A 的反向转换。当然，我们可以在 InstCombine 中实现一个方向的变换和另一个方向的变换，并根据目标进行选择。 但是这意味着其他的转换存需要同时考虑同一模式的两种不同形式。 当多种不同的转换组合时，我们还需要考虑避免死循环的出现，这大大增加了转换代码的复杂度。更好的选择是在 InstCombine 中确定一个方向，这样中端需要处理一个单一的规范模式，并将撤消转换移到后端。
规范化pass的另一个例子是 LICM。 LICM 会将所有循环不变代码移动到循环头中。 这并不总是有利的，因为它可能会增加寄存器压力，或者无条件地执行以前有条件的代码。假设另一种 LICM 实现，它将通过 TTI 考虑寄存器压力，并使用 PGO 信息考虑代码热度。然而，这意味着其他转换不能依赖这些循环不变操作数是循环不变的。LLVM 选择使 LICM 成为规范化转换，稍后可能会被其他通道撤消。 后期中端优化流水线中的LoopSink是基于PGO的，而MachineSink是后端pass。
当然，关于 TTI 依赖 pass 的政策有时需要做出一定的权衡。 例如，我们需要区分使用 TTI 进行成本模型查询和合法性查询。虽然合法性查询最好由内存布局来回答，但事实是添加新的 TTI hook 比在内存布局中编码附加信息要简单得多。 因此，在与目标无关的过程中允许 TTI 合法性查询通常是务实的选择。
即使是 InstCombine pass，它可能是针对目标相关转换的最难策略的地方，也确实使用 TTI 的 hook 来折叠目标相关 intrinsics。 我们最终关心的是规范的 IR 形式尽可能保持目标独立。但目标相关 intrinsics 自然不能具有与目标无关的规范形式。
### 规范形式
规范的 IR 形式没有在任何地方记录，基本上可以归结为：只要 InstCombine 做出选择，它产生的 IR 就是规范的 IR。 在某些情况下，规范形式的选择是显而易见的。 如果可以用更少的指令做同样的事情，那几乎总是更可取的（例外可能是昂贵的指令，如整数除法或某些 intrinsics）。
当两个序列具有相同数量的指令时，这个问题就变得更有趣了。 例如，考虑以下等效模式：

```
%tmp = add i32 %x, 2
%res = mul i32 %tmp, 3

%tmp = mul i32 %x, 3
%res = add i32 %tmp, 6
```
原则上，这可以在任一方向上规范化，并且有人可能会争辩说前者更好，因为它导致更小的常数。然而，我们更喜欢后者。 为什么这是一个更好的选择有几个原因，但最主要的是我们总是可以将前者转换为后者，但反之则不然。 如果将加 6 更改为加 5，则不再可能分解出乘法。这使我们能够建立乘法和加法的规范排序，我们更喜欢“乘法相加”而不是“加法相乘”。 这种规范排序使模式在两步过程中折叠如下：

```
%tmp = add i32 %x, 2
%tmp2 = mul i32 %tmp, 3
%res = add i32 %tmp2, 5

; Step 1
%tmp = mul i32 %x, 3
%tmp2 = add i32 %tmp, 6
%res = add i32 %tmp2, 5

; Step 2
%tmp = mul i32 %x, 3
%res = add i32 %tmp, 11
```
作为另一个例子，让我们考虑这些模式：

```
%res = add i32 %x, %x

%res = shl i32 %x, 1
```
这些模式并不等同：后者是一种改进。 这意味着我们可以将前者转换为后者，但反过来需要插入 freeze 指令。 这样做的原因有点技术性，我不会在这里深入探讨。但即使没有这个顾虑，我们也会在这里对后一种模式进行规范化，因为它减少了 %x 的使用次数，这使得它更易于分析。 例如，shl 模式明确表示结果的低位为零，而这需要对 add 模式进行特殊分析才能得到。 只使用一次 %x 还可以更容易地将 shl 折叠到产生 %x 的任何操作中：

```
%x = mul i32 %y, 3
%res = add i32 %x, %x

; Step 1
%x = mul i32 %y, 3
%res = shl i32 %x, 1

; Step 2
%res = mul i32 %y, 6
```
根据经验，对于指令数量相同的两种模式，我们更喜欢使用较少的值的模式。
在这里我们还可以看到撤消转换的效果：x86 后端会将 shl %x, 1 转换回 add %x, %x 以形成 lea 指令。 规范的 IR 偏好与此处的目标偏好背道而驰。这些只是一些基本的例子。
InstCombine 执行成百上千种不同的变换，规范形式的选择并不总是显而易见的。 有时它完全是任意的，我们只是选择了一些东西，以便 CSE/GVN 看到一个单一的模式。有时规范形式会发生变化，因为我们意识到不同的形式可以更好地组合进一步的变换，或者不太容易出现死循环。 此类更改可能需要调整其他转换（和/或后端）以处理新的规范形式。 这些变化总是有些风险，因为它们可能会产生意想不到的影响。
无论如何，我希望这足以说明为什么我们关心规范的 IR 形式，以及它如何使得转换可互相组合。
### 总结
LLVM 中端通过三个主要来源依赖于目标：内存布局 (DL)、目标库信息 (TLI) 和目标转换信息 (TTI)。 使用前两个依赖一般没有问题，但后者的使用受到限制。像 InstCombine 这样的规范化过程不允许有依赖于目标的成本模型和依赖目标的抑制转换。 而应该在编译后端撤销不希望的规范化。
